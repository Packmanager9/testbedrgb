<!DOCTYPE html>
<html lang="en" dir="ltr">
    <head>
        <!-- <link rel="stylesheet" href="styles.css"> --></head>
    <canvas id="canvas" width="1280" height="850"></canvas>
    <script>

let ws
let HOST = location.origin.replace(/^http/, 'ws')
ws = new WebSocket(HOST);
let playerID = 0 //Math.floor(Math.random()*2)
let worldID = Math.floor(Math.random()*10000)
const gamepadAPI = {
        controller: {},
        turbo: true,
        connect: function (evt) {
            if (navigator.getGamepads()[0] != null) {
                gamepadAPI.controller = navigator.getGamepads()[0]
                gamepadAPI.turbo = true;
            } else if (navigator.getGamepads()[1] != null) {
                gamepadAPI.controller = navigator.getGamepads()[0]
                gamepadAPI.turbo = true;
            } else if (navigator.getGamepads()[2] != null) {
                gamepadAPI.controller = navigator.getGamepads()[0]
                gamepadAPI.turbo = true;
            } else if (navigator.getGamepads()[3] != null) {
                gamepadAPI.controller = navigator.getGamepads()[0]
                gamepadAPI.turbo = true;
            }
            for (let i = 0; i < gamepads.length; i++) {
                if (gamepads[i] === null) {
                    continue;
                }
                if (!gamepads[i].connected) {
                    continue;
                }
            }
        },
        disconnect: function (evt) {
            gamepadAPI.turbo = false;
            delete gamepadAPI.controller;
        },
        update: function () {
            gamepadAPI.controller = navigator.getGamepads()[0]
            gamepadAPI.buttonsCache = [];// clear the buttons cache
            for (var k = 0; k < gamepadAPI.buttonsStatus.length; k++) {// move the buttons status from the previous frame to the cache
                gamepadAPI.buttonsCache[k] = gamepadAPI.buttonsStatus[k];
            }
            gamepadAPI.buttonsStatus = [];// clear the buttons status
            var c = gamepadAPI.controller || {}; // get the gamepad object
            var pressed = [];
            if (c.buttons) {
                for (var b = 0, t = c.buttons.length; b < t; b++) {// loop through buttons and push the pressed ones to the array
                    if (c.buttons[b].pressed) {
                        pressed.push(gamepadAPI.buttons[b]);
                    }
                }
            }
            var axes = [];
            if (c.axes) {
                for (var a = 0, x = c.axes.length; a < x; a++) {// loop through axes and push their values to the array
                    axes.push(c.axes[a].toFixed(2));
                }
            }
            gamepadAPI.axesStatus = axes;// assign received values
            gamepadAPI.buttonsStatus = pressed;
            // console.log(pressed); // return buttons for debugging purposes
            return pressed;
        },
        buttonPressed: function (button, hold) {
            var newPress = false;
            for (var i = 0, s = gamepadAPI.buttonsStatus.length; i < s; i++) {// loop through pressed buttons
                if (gamepadAPI.buttonsStatus[i] == button) {// if we found the button we're looking for...
                    newPress = true;// set the boolean variable to true
                    if (!hold) {// if we want to check the single press
                        for (var j = 0, p = gamepadAPI.buttonsCache.length; j < p; j++) {// loop through the cached states from the previous frame
                            if (gamepadAPI.buttonsCache[j] == button) { // if the button was already pressed, ignore new press
                                newPress = false;
                            }
                        }
                    }
                }
            }
            return newPress;
        },
        buttons: [
            'A', 'B', 'X', 'Y', 'LB', 'RB', 'Left-Trigger', 'Right-Trigger', 'Back', 'Start', 'Axis-Left', 'Axis-Right', 'DPad-Up', 'DPad-Down', 'DPad-Left', 'DPad-Right', "Power"
        ],
        buttonsCache: [],
        buttonsStatus: [],
        axesStatus: []
    };

let roomslist = []

const squaretable = {} // this section of code is an optimization for use of the hypotenuse function on Line and LineOP objects
for (let t = 0; t < 10000000; t++) {
    squaretable[`${t}`] = Math.sqrt(t)
    if (t > 999) {
        t += 9
    }
}

let setup_canvas = document.getElementById('canvas') 

let canvas
let canvas_context
let keysPressed = {}
let FLEX_engine
let TIP_engine = {}
let XS_engine
let YS_engine
setUp(setup_canvas)

class LineOP {
    constructor(object, target, color, width) {
        this.object = object
        this.target = target
        this.color = color
        this.width = width
    }

intersects(line) {

    if((this.object.y == line.object.y && this.object.x == line.object.x) || (this.target.y == line.object.y && this.target.x == line.object.x) || (this.target.y == line.target.y && this.target.x == line.target.x) || (this.object.y == line.target.y && this.object.x == line.target.x) ){
        return false
    }

    var det, gm, lm;
    if (line) {
        if (this.target) {
            if (this.object) {
                if (line.object) {
                    if (line.target) {
                        det = (this.target.x - this.object.x) * (line.target.y - line.object.y) - (line.target.x - line.object.x) * (this.target.y - this.object.y);
                    }
                }
            }
        }
    }
    if (det === 0) {
        return false;
    } else {
        if (line) {
            if (this.target) {
                if (this.object) {
                    if (line.object) {
                        if (line.target) {
                            lm = ((line.target.y - line.object.y) * (line.target.x - this.object.x) + (line.object.x - line.target.x) * (line.target.y - this.object.y)) / det;
                            gm = ((this.object.y - this.target.y) * (line.target.x - this.object.x) + (this.target.x - this.object.x) * (line.target.y - this.object.y)) / det;


                            return (0 <= lm && lm <= 1) && (0 <= gm && gm <= 1);
                        }
                    }
                }
            }
        }
        return false
    }
}
    squareDistance() {
        let xdif = this.object.x - this.target.x
        let ydif = this.object.y - this.target.y
        let squareDistance = (xdif * xdif) + (ydif * ydif)
        return squareDistance
    }
    hypotenuse() {
        let xdif = this.object.x - this.target.x
        let ydif = this.object.y - this.target.y
        let hypotenuse = (xdif * xdif) + (ydif * ydif)
        if (hypotenuse < 10000000 - 1) {
            if (hypotenuse > 1000) {
                return squaretable[`${Math.round(10 * Math.round((hypotenuse * .1)))}`]
            } else {
                return squaretable[`${Math.round(hypotenuse)}`]
            }
        } else {
            return Math.sqrt(hypotenuse)
        }
    }
    angle() {
        return Math.atan2(this.object.y - this.target.y, this.object.x - this.target.x)
    }
    draw() {
        let linewidthstorage = canvas_context.lineWidth
        canvas_context.strokeStyle = this.color
        canvas_context.lineWidth = this.width
        canvas_context.beginPath()
        canvas_context.moveTo(this.object.x, this.object.y)
        canvas_context.lineTo(this.target.x, this.target.y)
        canvas_context.stroke()
        canvas_context.lineWidth = linewidthstorage
    }
}
class Rectangle {
    constructor(x,y,w,h,c){
        this.x = x
        this.y = y
        this.h = h
        this.w = w
        this.color = c
    }
    draw(){
        canvas_context.fillStyle = this.color
        canvas_context.fillRect(this.x, this.y, this.w, this.h)
    }
    isPointInside(point) {
        if (point.x >= this.x) {
            if (point.y >= this.y) {
                if (point.x <= this.x + this.w) {
                    if (point.y <= this.y + this.h) {
                        return true
                    }
                }
            }
        }
        return false
    }
}

class Circle {
    constructor(x, y, radius, color, xmom, ymom) {
        this.x = x
        this.y = y
        this.xmom = xmom
        this.ymom = ymom
        this.radius = radius
        this.color = color
    }
    move(){
        this.x += this.xmom
        this.y += this.ymom
    }
    draw() {
        canvas_context.lineWidth = 1
        canvas_context.strokeStyle = "black"
        // canvas_context.strokeStyle = this.color
        canvas_context.beginPath();
            canvas_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
            canvas_context.fillStyle = this.color
            canvas_context.fill()
            canvas_context.stroke()
    }
    adraw() {
        canvas_context.lineWidth = this.strokeWidth
        canvas_context.strokeStyle = "white"
        canvas_context.beginPath();
            canvas_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
            canvas_context.fillStyle = this.color
            canvas_context.stroke()
            canvas_context.closePath()
    }
        isPointInside(point) {
            this.areaY = point.y - this.y
            this.areaX = point.x - this.x
            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
                return true
            }
            return false
        }
        doesPerimeterTouch(point) {
            this.areaY = point.y - this.y
            this.areaX = point.x - this.x
            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
                return true
            }
            return false
        }

}

let rock = new Image()
rock.src = "https://ditzbitz.com/rockRPS.png"
let paper = new Image()
paper.src = "https://ditzbitz.com/paperRPS.png"
let scissors = new Image()
scissors.src = "https://ditzbitz.com/scissorsRPS.png"

class Crew {
    constructor(tile, side, queen){
        this.health = 100
        this.maxhealth = this.health
        this.queen = queen
        this.selected = 0
        this.side = side
        this.tile = tile
        this.body = new Circle(b.grid[tile].x+32, b.grid[tile].y, 17, "")
        this.body.color = "red"
        if(this.side == 1){
            this.body.color = "#00ff00"
        }
    }
    draw(){
        if(this.health > 0){

        }else{
            return
        }

        if(this.selected == 1){
            let x1 = Math.max(100, this.body.x-160)
            let y1 = Math.max(100, this.body.y-160)
            let wcap = Math.max(160- (this.body.x-100), 0)
            let hcap = Math.max(160- (this.body.y-100), 0)
            
            let rect = new Rectangle(x1, y1, 320-wcap, 320-hcap, "")
            if(rect.x+rect.w > (64*9)+100){
                let d =  (rect.x+rect.w) - ((64*9)+100)
                // rect.x -=d
                rect.w -=d
            }
            if(rect.y+rect.h > (64*9)+100){
                let d =  (rect.y+rect.h) - ((64*9)+100)
                // rect.y -=d
                rect.h -=d
            }
            rect.color = "#00ff0044"
            if(this.side == 1){
                rect.color = "#00ff0044"
            }
            rect.draw()
        }
        this.body.radius = 15
        this.body.x = b.grid[this.tile].x + 32 
        this.body.y = b.grid[this.tile].y + 32
        if(b.turn == this.side){
            this.body.color = "white"
            this.body.radius += 2 + (this.selected*5)
        this.body.adraw()
        this.body.radius -=2 + (this.selected*5)
        }
        this.body.color = "#FFFFFF"
        if(this.side == 1){
            this.body.color = "#000000"
        }
        this.healthbar = new Rectangle(this.body.x-32, this.body.y-32, 64* (this.health/this.maxhealth), 4, "cyan")
        // this.body.draw()
        if(this.queen == 0){
            canvas_context.drawImage(rock, 0,0,30,30, this.body.x-15, this.body.y-15, 30,30)
        }
        if(this.queen == 1){
            canvas_context.drawImage(paper, 0,0,30,30, this.body.x-15, this.body.y-15, 30,30)
        }
        if(this.queen == 2){
            canvas_context.drawImage(scissors, 0,0,30,30, this.body.x-15, this.body.y-15, 30,30)
        }
        this.healthbar.draw()
    }
}

class Team{
    constructor(side){
        this.crew = []
        if(side == 0){
            let crew1 = new Crew(0, 0, 0)
            let crew2 = new Crew(1, 0, 1)
            let crew3 = new Crew(2, 0, 2)
            let crew4 = new Crew(3, 0, 0)
            let crew5 = new Crew(4, 0, 1)
            let crew6 = new Crew(5, 0, 2)
            let crew7 = new Crew(6, 0, 0)
            let crew8 = new Crew(7, 0, 1)
            let crew9 = new Crew(8, 0, 2)
            let crew10 = new Crew(9, 0, 2)
            let crew11 = new Crew(10, 0, 0)
            let crew12 = new Crew(11, 0, 1)
            let crew13 = new Crew(12, 0, 2)
            let crew14 = new Crew(13, 0, 0)
            let crew15 = new Crew(14, 0, 1)
            let crew16 = new Crew(15, 0, 2)
            let crew17 = new Crew(16, 0, 0)
            let crew18 = new Crew(17, 0, 1)
            this.crew.push(crew1)
            this.crew.push(crew2)
            this.crew.push(crew3)
            this.crew.push(crew4)
            this.crew.push(crew5)
            this.crew.push(crew6)
            this.crew.push(crew7)
            this.crew.push(crew8)
            this.crew.push(crew9)
            this.crew.push(crew10)
            this.crew.push(crew11)
            this.crew.push(crew12)
            this.crew.push(crew13)
            this.crew.push(crew14)
            this.crew.push(crew15)
            this.crew.push(crew16)
            this.crew.push(crew17)
            this.crew.push(crew18)
        }else{

            // let crew1 = new Crew(80-0, 1,1)
            // let crew2 = new Crew(80-1, 1, 0)
            // let crew3 = new Crew(80-6, 1, 1)
            // let crew4 = new Crew(80-7, 1, 0)
            // let crew5 = new Crew(80-2, 1, 2)
            // let crew6 = new Crew(80-3, 1, 1)
            // let crew7 = new Crew(80-8, 1, 2)
            // let crew8 = new Crew(80-9, 1, 1)
            // let crew9 = new Crew(80-4, 1, 0)
            // let crew10 = new Crew(80-5, 1, 2)
            // let crew11 = new Crew(80-10, 1, 0)
            // let crew12 = new Crew(80-11, 1, 2)
            // let crew13 = new Crew(80-12, 1, 1)
            // let crew14 = new Crew(80-13, 1, 0)
            // let crew15 = new Crew(80-14, 1, 2)
            // let crew16 = new Crew(80-15, 1, 1)
            // let crew17 = new Crew(80-16, 1, 0)
            // let crew18 = new Crew(80-17, 1, 2)

            let crew1 = new Crew(80-0, 1, 0)
            let crew2 = new Crew(80-1, 1, 1)
            let crew3 = new Crew(80-2, 1, 2)
            let crew4 = new Crew(80-3, 1, 0)
            let crew5 = new Crew(80-4, 1, 1)
            let crew6 = new Crew(80-5, 1, 2)
            let crew7 = new Crew(80-6, 1, 0)
            let crew8 = new Crew(80-7, 1, 1)
            let crew9 = new Crew(80-8, 1, 2)
            let crew10 = new Crew(80-9, 1, 2)
            let crew11 = new Crew(80-10, 1, 0)
            let crew12 = new Crew(80-11, 1, 1)
            let crew13 = new Crew(80-12, 1, 2)
            let crew14 = new Crew(80-13, 1, 0)
            let crew15 = new Crew(80-14, 1, 1)
            let crew16 = new Crew(80-15, 1, 2)
            let crew17 = new Crew(80-16, 1, 0)
            let crew18 = new Crew(80-17, 1, 1)
            this.crew.push(crew1)
            this.crew.push(crew2)
            this.crew.push(crew3)
            this.crew.push(crew4)
            this.crew.push(crew5)
            this.crew.push(crew6)
            this.crew.push(crew7)
            this.crew.push(crew8)
            this.crew.push(crew9)
            this.crew.push(crew10)
            this.crew.push(crew11)
            this.crew.push(crew12)
            this.crew.push(crew13)
            this.crew.push(crew14)
            this.crew.push(crew15)
            this.crew.push(crew16)
            this.crew.push(crew17)
            this.crew.push(crew18)
        }
        this.side = side
    }
    checkSel(){
        let wet = 0
        for(let t = 0;t<this.crew.length;t++){
            if(this.crew[t].selected == 1){
                wet = 1
            }
        }
        if(wet == 1){
            return true
        }
        return false

    }
    draw(){
        this.links = []

        let cap3 = [0,0,0]

        for(let t = 0;t<this.crew.length;t++){
            this.crew[t].conflict = 0
        }
        for(let t = 0;t<this.crew.length;t++){
            for(let k = t;k<this.crew.length;k++){
                if(this.crew[t]!= this.crew[k]){//new
                    if(this.crew[t].queen == this.crew[k].queen){
                    let link = new LineOP(this.crew[t].body, this.crew[k].body, this.crew[t].body.color, 2)
                    link.guy1 = this.crew[t]
                    link.guy2 = this.crew[k]
                    if(this.crew[t].queen==0){
                        if(this.side == 0){
                        link.color = "#FF8888"
                        }else{
                        link.color = "#AA4444"
                        }
                    }
                    if(this.crew[t].queen==1){
                        if(this.side == 0){
                        link.color = "#88FF88"
                        }else{
                        link.color = "#44AA44"
                        }
                    }
                    if(this.crew[t].queen==2){
                        if(this.side == 0){
                        link.color = "#8888FF"
                        }else{
                        link.color = "#4444AA"
                        }
                    }
                    this.links.push(link)
                    cap3[this.crew[t].queen] = 1
                    if(link.hypotenuse() <= 70){
                        link.guy1.conflict = 1
                        link.guy2.conflict = 1
                    }
                }
                }
            }
        }
        if(cap3[0]+cap3[1]+cap3[2] == 3){

        }else{
            if(this.side == 0){
                canvas_context.font = "40px arial"
                canvas_context.fillStyle = "Black"
                canvas_context.fillText("Black wins", 900, 350+(this.side*300))
            }else{
                canvas_context.font = "40px arial"
                canvas_context.fillStyle = "White"
                canvas_context.fillText("White wins", 900, 350+(this.side*300))
            }
        }

        this.total =0 
        for(let t = 0;t<this.links.length;t++){
            this.links[t].draw()
        }
        for(let t = 0;t<this.crew.length;t++){
            this.crew[t].draw()
            this.total+=this.crew[t].health
        }
        canvas_context.font = "40px arial"
        canvas_context.fillStyle = this.crew[0].body.color
        canvas_context.fillText(Math.round(this.total), 900, 300+(this.side*300))
        for(let t = 0;t<this.crew.length;t++){
                if(this.crew[t].health <= 0 ){
                    this.crew.splice(t,1)
                }
        }
    }
}

class Board{
    constructor(){
        this.turn = 0
        this.grid =[]
        for(let t =0;t<9;t++){
            for(let k =0;k<9;k++){
                let box = new Rectangle(100+(64*t), 100+(64*k), 64, 64, "")
                if(t%2 == 1){
                    
                if( k%2 == 1){

                    box.color = "#888800"
                }else{
                    box.color = "#880088"
                }
                }
                if(t%2 == 0){
                    
                if( k%2 == 0){

                    box.color = "#888800"
                }else{
                    box.color = "#880088"
                }
                }
                this.grid.push(box)
            }
        }
        this.first = 0
        this.teams = []
    }
    check(){
          if(playerID != this.turn){
            return
          }
        let wet = 0
        for(let t = 0;t<this.teams.length;t++){
            if(this.teams[t].checkSel()){
                wet = 1
            }
        }
        if(wet == 0){
            for(let t = 0;t<this.teams.length;t++){
                for(let k = 0;k<this.teams[t].crew.length;k++){
                    this.teams[t].crew[k].selected =0
                }
            }
            for(let t = 0;t<this.teams.length;t++){
                for(let k = 0;k<this.teams[t].crew.length;k++){
                    let link = new LineOP(this.teams[t].crew[k].body, TIP_engine)
                    if(link.hypotenuse() < this.teams[t].crew[k].body.radius){
                        if(t == this.turn){
                            this.teams[t].crew[k].selected = 1
                        }
                    }
                }
            }

        }else{

            for(let t = 0;t<this.teams.length;t++){
                for(let k = 0;k<this.teams[t].crew.length;k++){
                    let link = new LineOP(this.teams[t].crew[k].body, TIP_engine)
                    if(link.hypotenuse() < this.teams[t].crew[k].body.radius){
                        if(t == this.turn){
                            if( this.teams[t].crew[k].selected  == 1){
                                this.teams[t].crew[k].selected = 0
                                return
                            }
                        }
                    }
                }
            }


            for(let t =0;t<this.grid.length;t++){
                if(this.grid[t].isPointInside(TIP_engine)){

                    let guy = {}
                    let wet = 0
                    let gf = -1
                        for(let r = 0;r<this.teams.length;r++){
                            for(let w = 0;w<this.teams[r].crew.length;w++){
                                if(this.teams[r].crew[w].tile == t){
                                    wet = 1
                                }
                                if(this.teams[r].crew[w].selected == 1){
                                  gf = w
                                    guy = this.teams[r].crew[w]
                                }
                            }
                        }

                        // let line = new LineOP(this.grid[guy.tile], this.grid[t])
                        // if(line.hypotenuse() < (64*1.5)){
                        if(Math.abs(this.grid[t].x - this.grid[guy.tile].x) <= 128  && Math.abs(this.grid[t].y - this.grid[guy.tile].y) <= 128 ){
                            if(wet == 0){
                                this.cald = 1
                                guy.tile = t
                                guy.selected = 0


                                let pson = {}
                                pson.id = this.turn
                                pson.guy = gf
                                pson.tile = t
                                pson.serverID = worldID
                                ws.send(JSON.stringify(pson))
                                this.turn++
                                this.turn%=2
                            break
                            }
                        }
                }
            }
        }

    }

    calcDamage(){
            for(let k = 0;k<this.teams[0].links.length;k++){
                for(let t = 0;t<this.teams[1].links.length;t++){
                    if(this.teams[0].links[k].intersects(this.teams[1].links[t])){
                        if(this.teams[0].links[k].guy1.queen == 0 && this.teams[1].links[t].guy1.queen == 1){
                            this.teams[0].links[k].guy2.health -= 10
                            this.teams[0].links[k].guy1.health -= 10
                        }else{
                            if(this.teams[0].links[k].guy1.queen == 1 && this.teams[1].links[t].guy1.queen == 0){
                            this.teams[1].links[t].guy2.health -= 10
                            this.teams[1].links[t].guy1.health -= 10
                            }
                        }
                        if(this.teams[0].links[k].guy1.queen == 1 && this.teams[1].links[t].guy1.queen == 2){
                            this.teams[0].links[k].guy2.health -= 10
                            this.teams[0].links[k].guy1.health -= 10
                        }else{
                            if(this.teams[0].links[k].guy1.queen == 2 && this.teams[1].links[t].guy1.queen == 1){
                            this.teams[1].links[t].guy2.health -= 10
                            this.teams[1].links[t].guy1.health -= 10
                            }
                        }
                        if(this.teams[0].links[k].guy1.queen == 2 && this.teams[1].links[t].guy1.queen == 0){
                            this.teams[0].links[k].guy2.health -= 10
                            this.teams[0].links[k].guy1.health -= 10
                        }else{
                            if(this.teams[0].links[k].guy1.queen == 0 && this.teams[1].links[t].guy1.queen == 2){
                            this.teams[1].links[t].guy2.health -= 10
                            this.teams[1].links[t].guy1.health -= 10
                            }
                        }
                    }
                }
            }

            for(let k = 0;k<this.teams[0].crew.length;k++){

                if(this.teams[0].crew[k].conflict == 1){
                        this.teams[0].crew[k].health -= 10
                    }
            }
                for(let t = 0;t<this.teams[1].crew.length;t++){
                    if(this.teams[1].crew[t].conflict == 1){
                        this.teams[1].crew[t].health -= 10
                    }
                }
        }
    makeTeams(){
        this.teams = []
        for(let t = 0;t<2;t++){
            this.teams.push(new Team(t))
        }
    }
    draw(){
        if(this.first == 0){
            this.first = 1
            this.makeTeams()
        }
        for(let t = 0;t<this.grid.length;t++){
            this.grid[t].draw()
        }
        for(let t = 0;t<this.teams.length;t++){
            this.teams[t].draw()
        }

        if(this.cald == 1){

            for(let t = 0;t<this.teams.length;t++){
            this.teams[t].draw()
        }
            this.calcDamage()
            this.cald = 0
        }
    }
}


let globalRoom = 1 //Math.floor(Math.random()*9999)
let b = new Board()
let startgame = 0

let goRect = new Rectangle(1000, 500, 200, 100, "Red")

let fellows = []
let center = new Circle(canvas.width*.5,canvas.height*.5)
// canvas_context.translate(-center.x, -center.y)
// canvas_context.scale(.5, .5)

class ShootFellow {
constructor(type, x,y){
    this.id = worldID
        this.r = 0
        this.g = 0
        this.b = 0
    this.type = type
    if(this.type == 0){
        this.r = 255
        this.g = 0
        this.b = 0
    }
    if(this.type == 1){
        this.r = 0
        this.g = 255
        this.b = 0
    }
    if(this.type == 2){
        this.r = 0
        this.g = 0
        this.b = 255
    }
    this.x = canvas.width*.5
    this.y = canvas.height*.5
    this.radius = 20
    this.shots = []
    this.shottimer = 10
    this.shotcount = 0
}
update(x= this.x, y= this.y, r = this.r,  g = this.g,  b = this.b){
    this.x = x
    this.y = y
    this.r = r
    this.g = g
    this.b = b
}
draw(){
    this.color = `rgb(${this.r},${this.g},${this.b})`

    if(this.id == worldID){

        // canvas_context.translate(-(this.x-canvas.width*.5), -(this.y-canvas.height*.5))

        let wet = 0
        if(keysPressed['w']){
            wet = 1
            this.y-=7
            canvas_context.translate(0, 7)
        }
        if(keysPressed['s']){
            wet = 1
            this.y+=7
            canvas_context.translate(0, -7)
        }
        if(keysPressed['a']){
            wet = 1
            this.x-=7
            canvas_context.translate(7, 0)
        }
        if(keysPressed['d']){
            wet = 1
            this.x+=7
            canvas_context.translate(-7, 0)
        }
        if(wet == 0){
        gamepad_control(this, 10)
        }
        let link1 = new LineOP(new Circle(10, -9999999), new Circle(10, 9999999), "black")
        link1.draw()
        let link2 = new LineOP(new Circle(10, 10),new Circle( 9999999, 10), "black")
        link2.draw()
         link2 = new LineOP(new Circle(canvas.width-10, 10), new Circle(canvas.width-10, 9999999), "black")
        link2.draw()
         link2 = new LineOP(new Circle(10, canvas.width-10), new Circle(999999, canvas.width-10), "black")
        link2.draw()
        if(this.x < 30){
            canvas_context.translate(this.x-30, 0)
            center.x += this.x-30
            this.x = 30
        }
        if(this.y < 30){
            canvas_context.translate(0, this.y-30)
            center.y += this.y-30
            this.y = 30
        }
        if(this.x > canvas.width-30){
            canvas_context.translate(this.x-(canvas.width-30), 0)
            center.x += (this.y-(canvas.width-30))
            this.x = canvas.width-30
        }
        if(this.y > canvas.width-30){
            canvas_context.translate(0, (this.y-(canvas.width-30)))
            center.y += (this.y-(canvas.width-30))
            this.y = canvas.width-30
        }

        this.body = new Circle(this.x, this.y, 20, this.color)
        
        for(let k = 0;k<fellows.length;k++){
            if(fellows[k].id != worldID){
                let j = 0
                while(this.body.doesPerimeterTouch(new Circle(fellows[k].x, fellows[k].y, 20, "black"))){
                    j++
                    if(j > 40){
                        break
                    }
                    let recyline = new LineOP(this.body, new Circle(fellows[k].x, fellows[k].y, 20, "black"))
                    let ang = recyline.angle()
                    this.x += Math.cos(ang)
                    this.y += Math.sin(ang)
                    this.body.x += Math.cos(ang)
                    this.body.y += Math.sin(ang)

            canvas_context.translate(0,  -Math.sin(ang))
            canvas_context.translate(-Math.cos(ang),  0)
            center.y  += Math.sin(ang)
            center.x  += Math.cos(ang)


                }
            }
        }
    }
    if(this.shotcount < this.shottimer){
        this.shotcount++
    }
    let spt = 0
    if (typeof (gamepadAPI.axesStatus[2]) != 'undefined') {
                if (typeof (gamepadAPI.axesStatus[3]) != 'undefined') {
                    if(Math.abs(gamepadAPI.axesStatus[2]) + Math.abs(gamepadAPI.axesStatus[3]) > .1){
                        spt = 1
                    }

                }
            }
    if(keysPressed[' '] || spt > 0){
        if(this.id == worldID){
            if(this.shotcount%this.shottimer == 0){
                this.shotcount = 0
                let tf = canvas_context.getTransform()
                let link  = new LineOP(this, new Circle(TIP_engine.x-tf.e, TIP_engine.y-tf.f))
            let shot = new Circle(this.body.x, this.body.y, 4.101, this.color, Math.cos(link.angle())*-12, Math.sin(link.angle())*-12)
            shot.life = 50

            if (typeof (gamepadAPI.axesStatus[2]) != 'undefined') {
                if (typeof (gamepadAPI.axesStatus[3]) != 'undefined') {
                    if(Math.abs(gamepadAPI.axesStatus[2]) + Math.abs(gamepadAPI.axesStatus[3]) > .1){
                    shot.xmom = gamepadAPI.axesStatus[2]*12
                    shot.ymom = gamepadAPI.axesStatus[3]*12
                    }

                }
            }
            this.shots.push(shot)
            }
        }
    }
    this.body = new Circle(this.x, this.y, 20, this.color)
    this.body.draw()
    for(let t = 0;t<this.shots.length;t++){
    this.shots[t].move()
    this.shots[t].life--
    let dot = new Circle(this.shots[t].x, this.shots[t].y, (4*((51-(50-this.shots[t].life))/50))+2, this.color)
    dot.draw()
    let wet = 0
        for(let k = 0;k<fellows.length;k++){
            if(wet == 0){
                if(this != fellows[k]){
                if(dot.doesPerimeterTouch(fellows[k])){
                let json = {}
                json.target = k+1
                json.id =fellows[k].id
                json.source = fellows.indexOf(this)
                json.r = this.r
                json.g = this.g
                json.b = this.b
                this.shots.splice(t, 1)
                json.serverID = worldID
                ws.send(JSON.stringify(json))
                wet = 1
            }
            }
            }
        }
    }
        if(this.id == worldID){
            canvas_context.fillStyle = "black"
            canvas_context.font = "9px arial"
            canvas_context.fillText("(You)", this.x- 10, this.y+3)
                let json = {}
                json.target = worldID
                json.id = worldID
                json.self = 1
                json.x = this.x
                json.y = this.y
                json.r = this.r
                json.g = this.g
                json.b = this.b
                json.shots = this.shots
                json.serverID = worldID
                ws.send(JSON.stringify(json))
        }
    for(let t = 0;t<this.shots.length;t++){
        if(this.shots[t].life <= 0){
            this.shots.splice(t,1)
        }
    }
}




}

for(let t = 0;t<1;t++){
    fellows.push(new ShootFellow(Math.floor(Math.random()*3), Math.random()*1280, Math.random()*720))
}
class Numbox {
    constructor(){
        this.number = globalRoom
        this.pressed = 0
    }
    draw(){
        if(this.number < 999){
            if(keysPressed['1']){
                if(this.pressed == 0){
                    this.pressed = 1
                    this.number = 0
                }
            this.number = parseInt(this.number + `1`, 10)
            keysPressed['1'] = false
        }
        if(keysPressed['2']){
                if(this.pressed == 0){
                    this.pressed = 1
                    this.number = 0
                }
            this.number = parseInt(this.number + `2`, 10)
            keysPressed['2'] = false
        }
        if(keysPressed['3']){
                if(this.pressed == 0){
                    this.pressed = 1
                    this.number = 0
                }
            this.number = parseInt(this.number + `3`, 10)
            keysPressed['3'] = false
        }
        if(keysPressed['4']){
                if(this.pressed == 0){
                    this.pressed = 1
                    this.number = 0
                }
            this.number = parseInt(this.number + `4`, 10)
            keysPressed['4'] = false
        }
        if(keysPressed['5']){
                if(this.pressed == 0){
                    this.pressed = 1
                    this.number = 0
                }
            this.number = parseInt(this.number + `5`, 10)
            keysPressed['5'] = false
        }
        if(keysPressed['6']){
                if(this.pressed == 0){
                    this.pressed = 1
                    this.number = 0
                }
            this.number = parseInt(this.number + `6`, 10)
            keysPressed['6'] = false
        }
        if(keysPressed['7']){
                if(this.pressed == 0){
                    this.pressed = 1
                    this.number = 0
                }
            this.number = parseInt(this.number + `7`, 10)
            keysPressed['7'] = false
        }
        if(keysPressed['8']){
                if(this.pressed == 0){
                    this.pressed = 1
                    this.number = 0
                }
            this.number = parseInt(this.number + `8`, 10)
            keysPressed['8'] = false
        }
        if(keysPressed['9']){
                if(this.pressed == 0){
                    this.pressed = 1
                    this.number = 0
                }
            this.number = parseInt(this.number + `9`, 10)
            keysPressed['9'] = false
        }
        if(keysPressed['0']){
                if(this.pressed == 0){
                    this.pressed = 1
                    this.number = 0
                }
            this.number = parseInt(this.number + `0`, 10)
            keysPressed['0'] = false
        }
        }else{
            if(keysPressed['1']){
                if(this.pressed == 0){
                    this.pressed = 1
                    this.number = 0
            this.number = parseInt(this.number + `1`, 10)
            keysPressed['1'] = false
                }
        }
        if(keysPressed['2']){
                if(this.pressed == 0){
                    this.pressed = 1
                    this.number = 0
            this.number = parseInt(this.number + `2`, 10)
            keysPressed['2'] = false
                }
        }
        if(keysPressed['3']){
                if(this.pressed == 0){
                    this.pressed = 1
                    this.number = 0
            this.number = parseInt(this.number + `3`, 10)
            keysPressed['3'] = false
                }
        }
        if(keysPressed['4']){
                if(this.pressed == 0){
                    this.pressed = 1
                    this.number = 0
            this.number = parseInt(this.number + `4`, 10)
            keysPressed['4'] = false
                }
        }
        if(keysPressed['5']){
                if(this.pressed == 0){
                    this.pressed = 1
                    this.number = 0
            this.number = parseInt(this.number + `5`, 10)
            keysPressed['5'] = false
                }
        }
        if(keysPressed['6']){
                if(this.pressed == 0){
                    this.pressed = 1
                    this.number = 0
            this.number = parseInt(this.number + `6`, 10)
            keysPressed['6'] = false
                }
        }
        if(keysPressed['7']){
                if(this.pressed == 0){
                    this.pressed = 1
                    this.number = 0
            this.number = parseInt(this.number + `7`, 10)
            keysPressed['7'] = false
                }
        }
        if(keysPressed['8']){
                if(this.pressed == 0){
                    this.pressed = 1
                    this.number = 0
            this.number = parseInt(this.number + `8`, 10)
            keysPressed['8'] = false
                }
        }
        if(keysPressed['9']){
                if(this.pressed == 0){
                    this.pressed = 1
                    this.number = 0
            this.number = parseInt(this.number + `9`, 10)
            keysPressed['9'] = false
                }
        }
        if(keysPressed['0']){
                if(this.pressed == 0){
                    this.pressed = 1
                    this.number = 0
            this.number = parseInt(this.number + `0`, 10)
            keysPressed['0'] = false
                }
        }

        }
        if(keysPressed['Backspace']){
            this.number = 0
        }
        canvas_context.font = "30px arial"
        canvas_context.fillStyle = "black"
        canvas_context.fillText("Type in a number and press the button to select a room", 100, 100)
        canvas_context.fillText("The first player in the room plays as white and goes first", 100, 150)
        canvas_context.fillText("Room: "+ this.number, 100, 200)
        canvas_context.fillText("Press Backspace to reset room number", 100, 250)


        canvas_context.fillText("Active rooms", 100, 400)
        // console.log(roomslist)
            for(let t = 0;t<roomslist.length;t++){
        canvas_context.font = "20px arial"
        canvas_context.fillStyle = "black"
        if(roomslist[t][0] != 0){

            canvas_context.fillText("Room: " + roomslist[t][0] + "     "+ roomslist[t][1]+'/'+'(no limit)', 100, 420+(t*22))
        }

            }

            if(Math.random() < .1){

let pson = {}
pson.queryTournament = 1

pson.serverID = worldID
ws.send(JSON.stringify(pson))
}

    }
}

let roombox = new Numbox()
function setUp(canvas_pass, style = "#888888") {
    canvas = canvas_pass
    canvas_context = canvas.getContext('2d');
    canvas.style.background = style
    window.setInterval(function () {
        if(startgame == 2){

            let pson = {}
                                pson.room = globalRoom
                                pson.serverID = worldID
                                ws.send(JSON.stringify(pson))
                                startgame = 1
        }else{
            if(startgame == 0){

                canvas_context.clearRect(-10000,-10000, canvas.width*1000, canvas.height*1000) 
                roombox.draw()
            goRect.draw()

            }else{
        main()
        for(let t = 0;t<fellows.length;t++){
            fellows[t].draw()
        }
                if(Math.random() < .1){

                                let pson = {}
                                pson.pinging = 1
                                // pson.queryTournament = 1
                                
                                ws.send(JSON.stringify(pson))
                }
                if(Math.random() < .1){

                                let pson = {}
                                // pson.pinging = 1
                                pson.queryTournament = 1
                                
                                pson.serverID = worldID
                                ws.send(JSON.stringify(pson))
                }

        canvas_context.font = "25px arial"
        canvas_context.fillStyle = "black"
        let sums = [0,0,0]
        for(let t = 0;t<fellows.length;t++){
            sums[0] += fellows[t].r
            sums[1] += fellows[t].g
            sums[2] += fellows[t].b
        }
                // canvas_context.fillText("Red Remaining: " + Math.floor(sums[0]) + "  Green Remaining: " +Math.floor( sums[1] )+ "  Blue Remaining: " + Math.floor(sums[2]), 60, 30)
            }
        }
    }, 25)
    document.addEventListener('keydown', (event) => {
        keysPressed[event.key] = true;
    });
    document.addEventListener('keyup', (event) => {
        delete keysPressed[event.key];
    });
    window.addEventListener('pointerdown', e => {
        FLEX_engine = canvas.getBoundingClientRect();
        XS_engine = e.clientX - FLEX_engine.left;
        YS_engine = e.clientY - FLEX_engine.top;
        TIP_engine.x = XS_engine //+ center.x
        TIP_engine.y = YS_engine //+ center.y
        TIP_engine.body = TIP_engine
        // b.check()
        if(goRect.isPointInside(TIP_engine)){
            globalRoom = roombox.number
            startgame = 2
        }
    });
        window.addEventListener('pointermove', continued_stimuli);
    window.addEventListener('pointerup', e => {
        // window.removeEventListener("pointermove", continued_stimuli);
    })
    function continued_stimuli(e) {
        FLEX_engine = canvas.getBoundingClientRect();
        XS_engine = e.clientX - FLEX_engine.left;
        YS_engine = e.clientY - FLEX_engine.top;
        TIP_engine.x = XS_engine //+ center.x
        TIP_engine.y = YS_engine// + center.y
        TIP_engine.body = TIP_engine
    }
}

function main(){
    if(keysPressed['Escape']){
        startgame = 0
        center.x = 0
        center.y = 0
    }

    gamepadAPI.update() //checks for button presses/stick movement on the connected controller)
    canvas_context.clearRect(-10000,-10000, canvas.width*1000, canvas.height*1000) 
    // b.draw()
}

function findIntersection(line1, line2) {
    const slope1 = (line1.target.y - line1.object.y) / (line1.target.x - line1.object.x);
    const yIntercept1 = line1.object.y - slope1 * line1.object.x;
  
    const slope2 = (line2.target.y - line2.object.y) / (line2.target.x - line2.object.x);
    const yIntercept2 = line2.object.y - slope2 * line2.object.x;
  
    let x = (yIntercept2 - yIntercept1) / (slope1 - slope2);
    let y = slope1 * x + yIntercept1;
    
    if(isNaN(x)){
        x =( line1.target.x + line1.object.x)/2
    }
    if(isNaN(y)){
        y =( line1.target.y + line1.object.y)/2
    }
    console.log( { x, y })
    return { x, y };
  }




  Socketize(ws)

//   let pson = {}
//                                 pson.room = globalRoom
//                                 ws.send(JSON.stringify(pson))
//                                 startgame = 1


function gamepad_control(object, speed = 1) { // basic control for objects using the controler
        //         console.log(gamepadAPI.axesStatus[1]*gamepadAPI.axesStatus[0]) //debugging

        // console.log(gamepadAPI.axesStatus, object)
        //     console.log(gamepadAPI.axesStatus, object)
            if (typeof (gamepadAPI.axesStatus[1]) != 'undefined') {
                if (typeof (gamepadAPI.axesStatus[0]) != 'undefined') {
                    object.x += (gamepadAPI.axesStatus[0] * speed)
                    object.y += (gamepadAPI.axesStatus[1] * speed)
                }
            }
    }
    

  let newboard = 0
  function Socketize(ws) {

      // console.log("0hit")

      // console.log("hit")
      ws.addEventListener("message", ({
          data
      }) => {

        // console.log(data)
        if(JSON.parse(data).clean){

            let pars = JSON.parse(data)
            console.log(pars)
            let found = 0
            if(pars.playerIDs.includes(worldID)){
                for(let t = 0;t<fellows.length;t++){
                    if(!pars.playerIDs.includes(fellows[t].id)){
                        fellows.splice(t,1)
                    }
                }
            }


         }else if(JSON.parse(data).self){
            let pars = JSON.parse(data)
            // console.log(worldID, pars.id)
            if(worldID != pars.id){
                let found = 0
                for(let t = 0;t<fellows.length;t++){
                    if(fellows[t].id == pars.id){
                        fellows[t].update(pars.x, pars.y, (0+(pars.r*10))/10,  (0+(pars.g*10))/10,  (0+(pars.b*10))/10)
                        found = 1
                        fellows[t].shots = []
            for(let s = 0;s<pars.shots.length;s++){
                let shot = new Circle(pars.shots[s].x, pars.shots[s].y, 4.101, "red", pars.shots[s].xmom,  pars.shots[s].ymom)
                shot.life = pars.shots[s].life

                fellows[t].shots.push(shot)
            }
                        break
                    }
                }
                if(found == 0){
                    let fellow = new ShootFellow(Math.floor(Math.random() *3), -1,-1)
                    fellow.id = pars.id
                    fellow.update(pars.x, pars.y, (0+(pars.r*10))/10,  (0+(pars.g*10))/10,  (0+(pars.b*10))/10)
                    fellows.push(fellow)
                    
                for(let t = 0;t<fellows.length;t++){
                    if(fellows[t].id == pars.id){
                    fellows[t].shots = []
            for(let s = 0;s<pars.shots.length;s++){
                let shot = new Circle(pars.shots[s].x, pars.shots[s].y, 4.101, "red", pars.shots[s].xmom,  pars.shots[s].ymom)
                shot.life = pars.shots[s].life

                fellows[t].shots.push(shot)
            }
        }
    }
                }
                // fellows[pars.target].update(pars.x, pars.y, (0+(pars.r*10))/10,  (0+(pars.g*10))/10,  (0+(pars.b*10))/10)
    
        }
        }else   if(JSON.parse(data).faction){
            playerID =JSON.parse(data).faction
            console.log(playerID)
        }else if (JSON.parse(data).target) {
            let pars = JSON.parse(data)
            pars.target--

            for(let t = 0;t<fellows.length;t++){
                    if(fellows[t].id == pars.id){
                        fellows[t].update(fellows[t].x, fellows[t].y, (pars.r+(fellows[t].r*10))/11,  (pars.g+(fellows[t].g*10))/11,  (pars.b+(fellows[t].b*10))/11)
                        // found = 1
                        break
                    }
                }


                    // fellows[pars.target].update(fellows[pars.target].x, fellows[pars.target].y, (pars.r+(fellows[pars.target].r*10))/11,  (pars.g+(fellows[pars.target].g*10))/11,  (pars.b+(fellows[pars.target].b*10))/11)
              } else{
                    // console.log(JSON.parse(data))
                if(JSON.parse(data).roomlist){
                    roomslist = JSON.parse(data).roomlist
                }else{

                    let rect = new Rectangle(10, 10, 20, 20, "#00FF00")
                rect.draw()
                }
              }
      })

  }
    </script>
    <div id="dog-image-container">
    </div id="go">
</html>
